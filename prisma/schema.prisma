// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id            Int           @id @default(autoincrement())
  email         String        @unique
  username      String?       @unique // Username único para URLs públicas
  password      String? // Contraseña hasheada (opcional para usuarios de Google)
  name          String?
  phone         String? // Campo para el número de celular
  photo         String?
  estado        String?
  departamento  String?
  ciudad        String?
  latitude      Float? // Latitud para mostrar en el mapa
  longitude     Float? // Longitud para mostrar en el mapa
  showOnMap     Boolean       @default(false) // Si el usuario quiere aparecer en el mapa público
  birthdate     DateTime? // Nuevo campo para la fecha de nacimiento
  birthskate    DateTime? // Nuevo campo para la fecha de nacimiento
  profileStatus String        @default("basic") // "basic" (solo Google) | "complete" (perfil completo)
  role          String        @default("skater") // "skater" | "judge" | "admin"
  isActive      Boolean       @default(true) // Si el usuario está activo
  teamId        Int? // ID del equipo al que pertenece
  createdAt     DateTime      @default(now())
  socials       SocialMedia[] // Relación con la tabla de redes sociales
  WishSkate     WishSkate?
  submissions   Submission[] // Relación con los envíos de trucos
  evaluations   Submission[] @relation("JudgeEvaluations") // Evaluaciones hechas como juez
  ownedTeams    Team[]       @relation("TeamOwner") // Equipos que ha creado
  team          Team?        @relation("TeamMembers", fields: [teamId], references: [id])
  votes            Vote[]           @relation // Votos realizados por el usuario
  followers        Follow[]         @relation("UserFollowers") // Usuarios que me siguen
  following        Follow[]         @relation("UserFollowing") // Usuarios que sigo
  teamInvitations  TeamInvitation[] @relation("TeamInvitations") // Invitaciones de equipo recibidas
  notifications    Notification[]   @relation("UserNotifications") // Notificaciones recibidas
}

model SocialMedia {
  id        Int     @id @default(autoincrement())
  userId    String  @unique // Email del usuario
  facebook  String?
  instagram String?
  tiktok    String?
  twitter   String?

  user User @relation(fields: [userId], references: [email]) // Relacionado por email
}

model WishSkate {
  id          Int     @id @default(autoincrement())
  userId      String  @unique // Email del usuario
  madero      String?
  trucks      String?
  ruedas      String?
  rodamientos String?
  tenis       String?

  user User @relation(fields: [userId], references: [email]) // Relacionado por email
}

model Challenge {
  id          Int          @id @default(autoincrement())
  level       Int // Nivel del reto (1-10, 0 para bonus)
  name        String // Nombre del truco (ej: "Ollie", "Kickflip")
  description String // Descripción del truco
  demoVideoUrl String // URL del video demo (YouTube)
  isBonus     Boolean      @default(false) // Si es un nivel bonus
  difficulty  String // "easy", "medium", "hard", "expert"
  points      Int          @default(100) // Puntos que otorga el truco
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  submissions Submission[] // Relación con los envíos de usuarios

  @@unique([level, isBonus]) // Solo puede haber un challenge por nivel (o un bonus)
}

model Submission {
  id           Int      @id @default(autoincrement())
  userId       String // Email del usuario
  challengeId  Int // ID del reto
  videoUrl     String // URL del video de YouTube del usuario
  status       String   @default("pending") // "pending", "approved", "rejected"
  score        Int? // Puntuación otorgada por el equipo (0-100)
  feedback     String? // Comentarios del equipo evaluador
  submittedAt  DateTime @default(now())
  evaluatedAt  DateTime? // Fecha de evaluación
  evaluatedBy  String? // Email del juez que evaluó

  // Campos de votación comunitaria
  upvotes          Int      @default(0) // Total de votos positivos
  downvotes        Int      @default(0) // Total de votos negativos
  voteCount        Int      @default(0) // Total de votos (upvotes + downvotes)
  communityApproved Boolean @default(false) // Si fue aprobado por la comunidad
  autoApprovedAt   DateTime? // Fecha de auto-aprobación por comunidad

  user      User      @relation(fields: [userId], references: [email])
  challenge Challenge @relation(fields: [challengeId], references: [id])
  judge     User?     @relation("JudgeEvaluations", fields: [evaluatedBy], references: [email])
  votes     Vote[] // Relación con los votos

  @@index([userId, challengeId])
  @@index([status])
  @@index([evaluatedBy])
  @@index([communityApproved])
  @@index([voteCount])
}

model Team {
  id          Int      @id @default(autoincrement())
  name        String   @unique // Nombre del equipo (único)
  description String? // Descripción del equipo
  logo        String? // URL del logo del equipo
  ownerId     String // Username del creador del equipo
  maxMembers  Int      @default(5) // Máximo de miembros permitidos
  isActive    Boolean  @default(true) // Si el equipo está activo
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner       User             @relation("TeamOwner", fields: [ownerId], references: [username])
  members     User[]           @relation("TeamMembers") // Miembros del equipo
  invitations TeamInvitation[] // Invitaciones pendientes

  @@index([ownerId])
  @@index([isActive])
}

model TeamInvitation {
  id               Int      @id @default(autoincrement())
  teamId           Int // ID del equipo
  invitedUserEmail String // Email del usuario invitado
  status           String   @default("pending") // "pending", "accepted", "rejected"
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  team        Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  invitedUser User @relation("TeamInvitations", fields: [invitedUserEmail], references: [email], onDelete: Cascade)

  @@unique([teamId, invitedUserEmail]) // No se puede invitar al mismo usuario dos veces al mismo equipo
  @@index([invitedUserEmail])
  @@index([status])
}

model Vote {
  id           Int      @id @default(autoincrement())
  submissionId Int // ID de la submission votada
  userId       String // Email del usuario que vota
  voteType     String // "upvote" o "downvote"
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  submission Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [email])

  @@unique([submissionId, userId]) // Un usuario solo puede votar una vez por submission
  @@index([submissionId])
  @@index([userId])
  @@index([voteType])
}

model Follow {
  id          Int      @id @default(autoincrement())
  followerId  String // Email del usuario que sigue
  followingId String // Email del usuario seguido
  createdAt   DateTime @default(now())

  follower  User @relation("UserFollowers", fields: [followerId], references: [email])
  following User @relation("UserFollowing", fields: [followingId], references: [email])

  @@unique([followerId, followingId]) // Un usuario no puede seguir al mismo usuario dos veces
  @@index([followerId])
  @@index([followingId])
}

model InterestedUser {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Notification {
  id          Int      @id @default(autoincrement())
  userId      String // Email del usuario que recibe la notificación
  type        String // "submission_evaluated", "team_invitation", "ranking_update", "new_follower", "vote_received", etc.
  title       String // Título corto de la notificación
  message     String // Mensaje descriptivo
  link        String? // URL a donde debe redirigir (opcional)
  isRead      Boolean  @default(false) // Si la notificación fue leída
  metadata    Json? // Datos adicionales en formato JSON (score, judgeEmail, etc.)
  createdAt   DateTime @default(now())

  user User @relation("UserNotifications", fields: [userId], references: [email], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([type])
  @@index([createdAt])
}

model AppSettings {
  id               Int      @id @default(autoincrement())
  key              String   @unique // Clave única del setting (ej: "total_levels")
  value            String // Valor del setting
  description      String? // Descripción del setting
  updatedAt        DateTime @updatedAt
  updatedBy        String? // Email del admin que actualizó

  @@index([key])
}

model Spot {
  id          Int      @id @default(autoincrement())
  name        String // Nombre del spot (ej: "Skatepark Los Andes", "Tory Skateshop")
  type        String // "skatepark" o "skateshop"
  description String? // Descripción del lugar
  address     String? // Dirección completa
  city        String? // Ciudad
  state       String? // Estado/Departamento
  country     String   @default("Colombia") // País
  latitude    Float // Latitud para el mapa
  longitude   Float // Longitud para el mapa
  phone       String? // Teléfono de contacto
  website     String? // Sitio web
  instagram   String? // Usuario de Instagram (sin @)
  photos      String[] @default([]) // URLs de fotos del spot
  features    String[] @default([]) // Features: "street", "bowl", "mini-ramp", "vert", etc.
  isVerified  Boolean  @default(false) // Si fue verificado por admin
  rating      Float?   @default(0) // Rating promedio (0-5)
  reviewCount Int      @default(0) // Número de reviews
  createdBy   String // Email del usuario que lo creó
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([type])
  @@index([city])
  @@index([isVerified])
  @@index([latitude, longitude]) // Índice geoespacial para búsquedas por ubicación
}
