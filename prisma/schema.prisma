// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id            Int           @id @default(autoincrement())
  email         String        @unique
  username      String?       @unique // Username único para URLs públicas
  password      String? // Contraseña hasheada (opcional para usuarios de Google)
  name          String?
  phone         String? // Campo para el número de celular
  photo         String?
  estado        String?
  departamento  String?
  ciudad        String?
  latitude      Float? // Latitud para mostrar en el mapa
  longitude     Float? // Longitud para mostrar en el mapa
  showOnMap     Boolean       @default(false) // Si el usuario quiere aparecer en el mapa público
  birthdate     DateTime? // Nuevo campo para la fecha de nacimiento
  birthskate    DateTime? // Nuevo campo para la fecha de nacimiento
  profileStatus String        @default("basic") // "basic" (solo Google) | "complete" (perfil completo)
  role          String        @default("skater") // "skater" | "judge" | "admin"
  isActive      Boolean       @default(true) // Si el usuario está activo
  teamId        Int? // ID del equipo al que pertenece
  createdAt     DateTime      @default(now())
  socials       SocialMedia[] // Relación con la tabla de redes sociales
  WishSkate     WishSkate?
  submissions   Submission[] // Relación con los envíos de trucos
  evaluations   Submission[] @relation("JudgeEvaluations") // Evaluaciones hechas como juez
  ownedTeams    Team[]       @relation("TeamOwner") // Equipos que ha creado
  team          Team?        @relation("TeamMembers", fields: [teamId], references: [id])
  votes            Vote[]           @relation // Votos realizados por el usuario
  followers        Follow[]         @relation("UserFollowers") // Usuarios que me siguen
  following        Follow[]         @relation("UserFollowing") // Usuarios que sigo
  teamInvitations  TeamInvitation[] @relation("TeamInvitations") // Invitaciones de equipo recibidas
  notifications    Notification[]   @relation("UserNotifications") // Notificaciones recibidas
  comments         SpotComment[] // Comentarios del usuario
  commentVotes     CommentVote[] // Votos en comentarios
}

model SocialMedia {
  id        Int     @id @default(autoincrement())
  userId    String  @unique // Email del usuario
  facebook  String?
  instagram String?
  tiktok    String?
  twitter   String?

  user User @relation(fields: [userId], references: [email]) // Relacionado por email
}

model WishSkate {
  id          Int     @id @default(autoincrement())
  userId      String  @unique // Email del usuario
  madero      String?
  trucks      String?
  ruedas      String?
  rodamientos String?
  tenis       String?

  user User @relation(fields: [userId], references: [email]) // Relacionado por email
}

model Challenge {
  id          Int          @id @default(autoincrement())
  level       Int // Nivel del reto (1-10, 0 para bonus)
  name        String // Nombre del truco (ej: "Ollie", "Kickflip")
  description String // Descripción del truco
  demoVideoUrl String // URL del video demo (YouTube)
  isBonus     Boolean      @default(false) // Si es un nivel bonus
  difficulty  String // "easy", "medium", "hard", "expert"
  points      Int          @default(100) // Puntos que otorga el truco
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  submissions Submission[] // Relación con los envíos de usuarios

  @@unique([level, isBonus]) // Solo puede haber un challenge por nivel (o un bonus)
}

model Submission {
  id           Int      @id @default(autoincrement())
  userId       String // Email del usuario
  challengeId  Int // ID del reto
  videoUrl     String // URL del video de YouTube del usuario
  status       String   @default("pending") // "pending", "approved", "rejected"
  score        Int? // Puntuación otorgada por el equipo (0-100)
  feedback     String? // Comentarios del equipo evaluador
  submittedAt  DateTime @default(now())
  evaluatedAt  DateTime? // Fecha de evaluación
  evaluatedBy  String? // Email del juez que evaluó

  // Campos de votación comunitaria
  upvotes          Int      @default(0) // Total de votos positivos
  downvotes        Int      @default(0) // Total de votos negativos
  voteCount        Int      @default(0) // Total de votos (upvotes + downvotes)
  communityApproved Boolean @default(false) // Si fue aprobado por la comunidad
  autoApprovedAt   DateTime? // Fecha de auto-aprobación por comunidad

  user      User      @relation(fields: [userId], references: [email])
  challenge Challenge @relation(fields: [challengeId], references: [id])
  judge     User?     @relation("JudgeEvaluations", fields: [evaluatedBy], references: [email])
  votes     Vote[] // Relación con los votos

  @@index([userId, challengeId])
  @@index([status])
  @@index([evaluatedBy])
  @@index([communityApproved])
  @@index([voteCount])
}

model Team {
  id          Int      @id @default(autoincrement())
  name        String   @unique // Nombre del equipo (único)
  description String? // Descripción del equipo
  logo        String? // URL del logo del equipo
  ownerId     String // Username del creador del equipo
  maxMembers  Int      @default(5) // Máximo de miembros permitidos
  isActive    Boolean  @default(true) // Si el equipo está activo
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner       User             @relation("TeamOwner", fields: [ownerId], references: [username])
  members     User[]           @relation("TeamMembers") // Miembros del equipo
  invitations TeamInvitation[] // Invitaciones pendientes

  @@index([ownerId])
  @@index([isActive])
}

model TeamInvitation {
  id               Int      @id @default(autoincrement())
  teamId           Int // ID del equipo
  invitedUserEmail String // Email del usuario invitado
  status           String   @default("pending") // "pending", "accepted", "rejected"
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  team        Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  invitedUser User @relation("TeamInvitations", fields: [invitedUserEmail], references: [email], onDelete: Cascade)

  @@unique([teamId, invitedUserEmail]) // No se puede invitar al mismo usuario dos veces al mismo equipo
  @@index([invitedUserEmail])
  @@index([status])
}

model Vote {
  id           Int      @id @default(autoincrement())
  submissionId Int // ID de la submission votada
  userId       String // Email del usuario que vota
  voteType     String // "upvote" o "downvote"
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  submission Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [email])

  @@unique([submissionId, userId]) // Un usuario solo puede votar una vez por submission
  @@index([submissionId])
  @@index([userId])
  @@index([voteType])
}

model Follow {
  id          Int      @id @default(autoincrement())
  followerId  String // Email del usuario que sigue
  followingId String // Email del usuario seguido
  createdAt   DateTime @default(now())

  follower  User @relation("UserFollowers", fields: [followerId], references: [email])
  following User @relation("UserFollowing", fields: [followingId], references: [email])

  @@unique([followerId, followingId]) // Un usuario no puede seguir al mismo usuario dos veces
  @@index([followerId])
  @@index([followingId])
}

model InterestedUser {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Notification {
  id          Int      @id @default(autoincrement())
  userId      String // Email del usuario que recibe la notificación
  type        String // "submission_evaluated", "team_invitation", "ranking_update", "new_follower", "vote_received", etc.
  title       String // Título corto de la notificación
  message     String // Mensaje descriptivo
  link        String? // URL a donde debe redirigir (opcional)
  isRead      Boolean  @default(false) // Si la notificación fue leída
  metadata    Json? // Datos adicionales en formato JSON (score, judgeEmail, etc.)
  createdAt   DateTime @default(now())

  user User @relation("UserNotifications", fields: [userId], references: [email], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([type])
  @@index([createdAt])
}

model AppSettings {
  id               Int      @id @default(autoincrement())
  key              String   @unique // Clave única del setting (ej: "total_levels")
  value            String // Valor del setting
  description      String? // Descripción del setting
  updatedAt        DateTime @updatedAt
  updatedBy        String? // Email del admin que actualizó

  @@index([key])
}

model Spot {
  id              Int      @id @default(autoincrement())
  uuid            String?  @unique @default(uuid()) // Opcional para migrar datos existentes
  name            String // Nombre del spot
  type            String // "skatepark", "skateshop", "spot"
  description     String? // Descripción del lugar
  address         String? // Dirección completa
  city            String? // Ciudad
  state           String? // Estado/Departamento
  country         String   @default("Colombia")
  latitude        Float // Latitud para el mapa
  longitude       Float // Longitud para el mapa

  // VECTOR DE CONFIANZA - Sistema de Validación Social
  confidenceScore Int      @default(0) // 0-200+
  stage           String   @default("GHOST") // "GHOST", "REVIEW", "VERIFIED", "LEGENDARY", "STALE", "DEAD"
  lastVerifiedAt  DateTime @default(now())

  // Historial para decaimiento temporal
  statusHistory   Json     @default("[]") // [{action, weight, userId, timestamp}]

  // Spot "hot" = mucha actividad reciente
  isHot           Boolean  @default(false)
  hotUntil        DateTime? // Hasta cuándo mantiene el status "hot"

  // Información de contacto
  phone           String?
  website         String?
  instagram       String? // Usuario de Instagram (sin @)
  photos          String[] @default([]) // URLs de fotos del spot
  features        String[] @default([]) // Features: "street", "bowl", "mini-ramp", "vert", etc.
  rating          Float?   @default(0) // Rating promedio (0-5)
  reviewCount     Int      @default(0) // Número de reviews
  createdBy       String // Email del usuario que lo creó

  // Metadata para decaimiento
  lastActivityAt  DateTime @default(now())
  staleAt         DateTime? // Cuando empieza a decaer
  deadAt          DateTime? // Cuándo se considera "muerto"

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relaciones del sistema de validación
  validations     SpotValidation[]
  checkIns        SpotCheckIn[]
  photos_records  SpotPhoto[] @relation("SpotPhotos")
  reports         SpotReport[]
  comments        SpotComment[]

  @@index([type])
  @@index([city])
  @@index([stage, confidenceScore])
  @@index([isHot, lastActivityAt])
  @@index([latitude, longitude]) // Índice geoespacial
}

// ==================== SPOT VALIDATION SYSTEM ====================

model SpotValidation {
  id                Int      @id @default(autoincrement())
  spotId            Int
  userId            String // Email del usuario
  userWeight        Int      @default(1) // Peso según reputación (1-5)
  method            String // "GPS_PROXIMITY", "PHOTO_UPLOAD", "LIVE_PHOTO", "CHECK_IN", "CROWD_REPORT"

  // Anti-spam: Detección de patrones sospechosos
  ipAddress         String?
  deviceFingerprint String?

  // Datos GPS exactos en la validación
  validatedLat      Float?
  validatedLng      Float?
  accuracy          Float? // Precisión del GPS en metros

  createdAt         DateTime @default(now())

  spot              Spot     @relation(fields: [spotId], references: [id])

  @@unique([spotId, userId, method]) // Solo 1 validación por usuario/método
  @@index([spotId])
  @@index([userId, createdAt]) // Para detectar patrones de validación
}

model SpotCheckIn {
  id          Int      @id @default(autoincrement())
  spotId      Int
  userId      String // Email del usuario
  latitude    Float
  longitude   Float
  accuracy    Float? // Precisión GPS

  // Contexto del check-in
  crowdLevel  String? // "EMPTY", "LOW", "MODERATE", "BUSY", "CROWDED"
  isOpen      Boolean? // Para skateshops (¿está abierto?)

  createdAt   DateTime @default(now())

  spot        Spot     @relation(fields: [spotId], references: [id])

  @@index([spotId, createdAt])
  @@index([userId, createdAt]) // Para detectar patrones
}

model SpotPhoto {
  id        Int      @id @default(autoincrement())
  spotId    Int
  userId    String // Email del usuario
  url       String

  // Metadata EXIF para validar autenticidad
  isLive    Boolean  @default(false) // Foto tomada en tiempo real
  hasExif   Boolean  @default(false) // Tiene metadata GPS
  exifLat   Float? // Latitud del EXIF
  exifLng   Float? // Longitud del EXIF
  takenAt   DateTime? // Fecha en que se tomó la foto

  createdAt DateTime @default(now())

  spot      Spot     @relation("SpotPhotos", fields: [spotId], references: [id])

  @@index([spotId])
}

model SpotReport {
  id            Int      @id @default(autoincrement())
  spotId        Int
  userId        String // Email del usuario
  reason        String // "CLOSED", "FAKE", "DUPLICATE", "INCORRECT_LOCATION", "NO_LONGER_EXISTS", "INACCURATE_INFO"
  details       String?
  status        String   @default("PENDING") // "PENDING", "REVIEWED", "ACCEPTED", "REJECTED", "AUTO_VERIFIED"

  // Contexto del reporte
  reporterLat   Float?
  reporterLng   Float?
  wasOnLocation Boolean? // ¿El reportero estaba físicamente ahí?

  createdAt     DateTime @default(now())
  reviewedAt    DateTime?

  spot          Spot     @relation(fields: [spotId], references: [id])

  @@index([spotId, status])
}

// ==================== USER REPUTATION FOR VALIDATION ====================

model UserReputation {
  id                Int      @id @default(autoincrement())
  userId            String   @unique // Email del usuario
  reputationScore   Int      @default(0) // Puntos de reputación total
  level             String   @default("NEW") // "NEW", "TRUSTED", "VETERAN", "MASTER"
  validationWeight  Int      @default(1) // Peso de validación (1-5)

  // Estadísticas
  validationsGiven  Int      @default(0) // Validaciones realizadas
  spotsVerified     Int      @default(0) // Spots que ayudó a verificar
  reportsAccepted   Int      @default(0) // Reportes aceptados
  reportsRejected   Int      @default(0) // Reportes rechazados
  blindTestAccuracy Float    @default(0) // Precisión en pruebas ciegas (0-1)

  // Badges (JSON array de strings)
  badges            String[] @default([]) // ["Explorer", "Validator", "Guardian", "Legend"]

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([level])
  @@index([reputationScore])
}

// ==================== SPOT COMMENTS SYSTEM ====================

model SpotComment {
  id          Int      @id @default(autoincrement())
  spotId      Int
  userId      String // Email del usuario
  content     String   @db.Text
  likes       Int      @default(0)
  dislikes    Int      @default(0)
  isPinned    Boolean  @default(false) // Comentario fijado por admin
  isHidden    Boolean  @default(false) // Oculto por baja puntuación o moderación
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  spot        Spot     @relation(fields: [spotId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [email])

  @@index([spotId])
  @@index([userId])
  @@index([createdAt])
  @@index([likes, dislikes]) // Para ordenar por popularidad
  votes      CommentVote[]
}

model CommentVote {
  id          Int      @id @default(autoincrement())
  commentId   Int
  userId      String // Email del usuario
  voteType    String // 'like' | 'dislike'
  createdAt   DateTime @default(now())

  comment     SpotComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user        User        @relation(fields: [userId], references: [email])

  @@unique([commentId, userId]) // Un voto por usuario por comentario
  @@index([commentId])
  @@index([userId])
  @@index([voteType])
}
